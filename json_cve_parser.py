#
# Copied from https://avleonov.com/2017/10/03/downloading-and-analyzing-nvd-cve-feed/
# Special thanks to Alexander V. Leonov for the code below to gather and parse the CVE dictionary
#
# this program expects a .zip file in the directory nvd/ for use as the
# NIST produced list of vulnerabilitys in json format.
#
# Execute: json_cve_parser.py
# Expect:  a data dump of all the CVE's with the three fields sent to standard output:
#             CVE-IDENTIFIER
#             Text description of the issue
#             Version strings for this issue.
# Input data file contains the triplet "vendor-product-version" with dashes.
# Must do a match on all 3 to decide to report the CVE.
# Then make an output format decision if the specific CVE is also found in the ignore list.
#
# Example microsoft-home_server-2003
# search for a match on the example "php-php-5.4.3"
#
########################################################################
from __future__ import print_function
"""
Command Line Interface for the CVE lookup.
"""
import argparse
from os import listdir
from os.path import isfile, join
import zipfile
import json
import fnmatch


parser = argparse.ArgumentParser(description="Lookup known vulnerabilities from yocto/RPM/SWID in the CVE")
parser.add_argument("packages", help="The list of packages to run through the lookup", type=open)
parser.add_argument("-a", "--fail", help="Severity value [0-10] over which it will be a FAILURE", type=float, default=3)
parser.add_argument("-i", "--ignore_file", help="""A File containing a new-line delimited list of specific CVE's to ignore
 (e.g.  CVE-2015-7697 ) . These CVE's will show up as skipped in the report""", type=open)
# Input argument processing
args = parser.parse_args()

# create a "list" called ignore_list
# elements to ignore are stored in "ignore_list" object.
ignore_list = {}
ignored_control_lookup = {}
if args.ignore_file is not None:
    # first column is CVE, 2nd column is human readable description of control taken
    # eg: CVE-2015-7696 , Device shall never allow decompression of arbitrary zip files
    iterator = 0
    for line in args.ignore_file:
        if line.find("#") == -1: # ignore lines beginning with a hash character
            cols = line.split(",") # split on ,
            if len(cols) > 0:
                cve_id = cols[0].strip()
                cve_control = "N/A"
                if len(cols) > 1:
                    cve_control = cols[1]
                # add them to the list
                ignore_list[iterator] = cve_id  # Entries to ignore stored here
                iterator += 1
                ignored_control_lookup[cve_id] = cve_control

# debug
# print ("ignore list start" )
# print ( ignore_list )
# print ("ignore list end" )

###################################################################
# https://www.geeksforgeeks.org/split-string-substrings-using-delimiter/
#
# This code is contributed by
# Surendra_Gangwar
#
# Python 3 implementation to split string
# into substrings on the basis of delimiter
# and return the substrings after split
#
# Input: string, delimiter
# Output: sub strings split by delimiter
#
def splitStrings(st, dl):
    word = ""

    # to count the number of split strings
    num = 0

    # adding delimiter character at
    # the end of str
    st += dl

    # length of str
    l = len(st)

    # traversing str from left to right
    substr_list = []
    for i in range(l):

        # if str[i] is not equal to the
        # delimiter character then accumulate
        # it to word
        if (st[i] != dl):
            word += st[i]

        else:

            # if word is not an empty string,
            # then add this word to the array
            # substr_list[]
            if (len(word) != 0):
                substr_list.append(word)

            # reset word
            word = ""

    # return the splitted strings
    return substr_list
    
###################################################################
# Contributed by Utkarsh Trivedi. 
# https://www.geeksforgeeks.org/compare-two-version-numbers/
# Method to compare two versions.
#
# Input: version string 1, version string 2
# Output: True if they match false otherwise
#
def versionCompare(v1, v2): 
    
    # This will split both the versions by '.' 
    arr1 = v1.split(".") 
    arr2 = v2.split(".")
    #print("Array1 = " + str(arr1)) 
    #print("Array2 = " + str(arr2))
  
    # Initializer for the version arrays 
    i = 0
    
    # v1 and v2 lengths can be different. Index the strings up to the
    # smaller of the two lengths
    array_index_limit = min(len(arr1),len(arr2))
    
    # We have taken into consideration that both the 
    # versions will contains equal number of delimiters 
    while(i < len(arr1) and i < array_index_limit): 
        if (arr1[i].isdigit() == True and arr2[i].isdigit() == True) :

            # Allow for wild card using "*"
            #if (arr1[i] ==  "*" or arr2[i] == "*") :
            #   print("Found a wild card")
            #   return True
                
            # Version 2 is greater than version 1 
            if int(arr2[i]) > int(arr1[i]): 
                return False
              
            # Version 1 is greater than version 2 
            if int(arr1[i]) > int(arr2[i]): 
                return False
      
        # We can't conclude till now 
        i += 1
          
    # Both the versions are equal 
    return True
            
###################################################################
#
# Main
#
# will hold entry triplets from the user provided input file called "packages"
# each elemenet has a vendor-package-version format including the "-" dash
package_set = set(open(args.packages.name,'r').read().split()) 

nist_json_cve_set = set()   # NIST provided json cve entries for searching only
nist_json_cve_list = []     # NIST provided json cve entries for output
header_printed = False
my_final_set = set()
my_final_list = []
FIELD_SPLIT_CHARACTER = '|'
files = [f for f in listdir("nvd/") if f.endswith('.zip') and isfile(join("nvd/", f))]
files.sort()
for file in files:
    archive  = zipfile.ZipFile(join("nvd/", file), 'r')
    jsonfile = archive.open(archive.namelist()[0])
    cve_dict = json.loads(jsonfile.read())

    if header_printed == False:
        print("CVE_data_timestamp: "    + str(cve_dict['CVE_data_timestamp']))
        print("CVE_data_version: "      + str(cve_dict['CVE_data_version']))
        print("CVE_data_format: "       + str(cve_dict['CVE_data_format']))
        print(" ")
        header_printed = True

    totalcvecount = int(str(cve_dict['CVE_data_numberOfCVEs']))
    for cveiterator in range(0, totalcvecount):    
       if len(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data']) > 0 :
           totalproductnamecount = len(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data'][0]['product']['product_data'])
           for product_iterator in range(0,totalproductnamecount):
              my_product_name = str(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data'][0]['product']['product_data'][0]['product_name'])

           my_vendor_name = str(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data'][0]['vendor_name'])
           my_current_cve = str(cve_dict['CVE_Items'][cveiterator]['cve']['CVE_data_meta']['ID'])
           my_current_cve_description = str(cve_dict['CVE_Items'][cveiterator]['cve']['description']['description_data'][0]['value'].encode("utf-8"))
           
           #
           # iterate over found version values to fill the set nist_json_cve_set with 
           # data of the vendor-product-version triplet
           #
           for productnameiterator in range(0, totalproductnamecount):
                if len(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data'][0]['product']['product_data'][productnameiterator]['version']['version_data']) > 0 :
                   totalversionrange = len(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data'][0]['product']['product_data'][productnameiterator]['version']['version_data'])
                   
                   for version_iterator in range(0, totalversionrange):
                      my_version = str(cve_dict['CVE_Items'][cveiterator]['cve']['affects']['vendor']['vendor_data'][0]['product']['product_data'][productnameiterator]['version']['version_data'][version_iterator]['version_value'])
                      nist_json_cve_entry = my_vendor_name + "-" + my_product_name + "-" + my_version
                      nist_json_cve_set.add(nist_json_cve_entry)
                      
                      nist_json_cve_list.append(nist_json_cve_entry + FIELD_SPLIT_CHARACTER + my_current_cve_description + FIELD_SPLIT_CHARACTER + my_current_cve)                      
                      # debug
                      # print ("Add this json cve entry " + nist_json_cve_entry )
    jsonfile.close()
    
    my_intersection_set = set()
    #
    # take advantage of the intersection method to find the matching elements
    # in the two sets.
    # output looks like this
    # 'haxx-curl-7.61.0', 'ntp-ntp-4.2.8', 'gnome-networkmanager-1.10.2', 'linux-linux_kernel-4.9.11' ... }
    #
    my_intersection_set = nist_json_cve_set.intersection(package_set)
        
    # 
    for nist_json_entry in iter(nist_json_cve_set):        
        
        # print("Nist json entry is " + str(nist_json_entry))
        #
        # Iterate across all elements in the package_set
        for pattern in iter(package_set):
            #print("Pattern is " + str(pattern))
            nist_json_entry_str = str(nist_json_entry).split('-')
            nist_json_entry_str_len = len(nist_json_entry_str)
            pattern_str = str(pattern).split('-')
            
            # debug
            # print("nist json entry str " + nist_json_entry_str[2])
            # print("pattern_str 2 " + pattern_str[2])
            if (nist_json_entry_str_len == 3 and len(pattern_str) == 3):
                if (nist_json_entry_str[0] == pattern_str[0]):
                    if (nist_json_entry_str[1] == pattern_str[1]):
                        if (versionCompare(nist_json_entry_str[2], pattern_str[2])):
                            print("searched for " + str(pattern) + " match is: " + str(nist_json_entry))

    my_sub_string = []
    # --------------------------------------------------------------------
    # For each item found in my_intersection_set create a report with 
    # the CVE_ID and description.        
    # --------------------------------------------------------------------
    for my_intersection_set_iterator in range(len(my_intersection_set)):        
        possible_cve_match = my_intersection_set.pop()
        # Convert each entry into a list object for output formatting.
        Output = list(filter(lambda x:possible_cve_match in x, nist_json_cve_list))        
        for outputs_iterator in range(len(Output)):
            output_str = str(Output[outputs_iterator]).strip('[]')
            my_sub_strings = splitStrings(output_str, FIELD_SPLIT_CHARACTER)
            #
            # Version number check since the set.intersection() returns an inexact match.
            #
            pcm_version = str(possible_cve_match).split('-')
            mss_version = my_sub_strings[0].split('-')
            if pcm_version[2] == mss_version[2]:            
                # print(my_sub_strings[2] + " " + my_sub_strings[0])
                # If the issue is not in the ignore list, then mark it with a warning
                heading = "<warning> "
                for ignored_cve_iter in range(len(ignore_list)):
                    if my_sub_strings[2] == ignore_list[ignored_cve_iter]:
                        heading = "<skipped> "                
                #
                # Store the output triplet CVE ID, package name, description in a list so 
                # the list can be sorted and then only unique entries are preserved.
                # list { 'cve id' 'package name' 'description' }
                my_final_list.append(my_sub_strings[2] + FIELD_SPLIT_CHARACTER + my_sub_strings[0] + FIELD_SPLIT_CHARACTER + heading + my_sub_strings[1])
                #debug
                #print("Adding this entry " + my_sub_strings[2] + FIELD_SPLIT_CHARACTER + my_sub_strings[0] + FIELD_SPLIT_CHARACTER + heading + my_sub_strings[1]) 
        #
    # 
# All files processed at this point
#               
my_final_list.sort()              # sorted
my_final_set = set(my_final_list) # unique
my_final_list = sorted(my_final_set) # sorted

for x in range(len(my_final_list)):
    list_element = my_final_list[x]
    my_sub_strings = splitStrings(str(list_element), FIELD_SPLIT_CHARACTER)
    print(my_sub_strings[0]) 
    print(my_sub_strings[1])
    print(my_sub_strings[2])
    print()
    
# EOF
